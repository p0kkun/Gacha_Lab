# LINE ミニアプリ（LIFF）での友達紹介システム実装方法

## 概要

LINE LIFF アプリ内で友達紹介システムを実現する方法を説明します。

---

## 実装の流れ

### 1. 紹介リンクの生成

#### 方法 1: URL パラメータに紹介者 ID を含める（推奨）

```
https://your-liff-app.com/?ref=REFERRAL_LINK_ID
```

**実装例：**

```typescript
// 紹介リンクの生成
const generateReferralLink = async (userId: string) => {
  // 1. データベースに紹介履歴を保存
  const referralLinkId = crypto.randomUUID(); // 一意のIDを生成

  const referral = await prisma.referralHistory.create({
    data: {
      referrerId: userId,
      referralLinkId: referralLinkId,
      referralLink: `${process.env.NEXT_PUBLIC_LIFF_URL}?ref=${referralLinkId}`,
      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30日後
      status: "pending",
      isFraudDetected: false,
    },
  });

  return referral.referralLink;
};
```

#### 方法 2: 短縮 URL を使用（オプション）

- より短い URL を生成したい場合
- 短縮 URL サービス（bit.ly、TinyURL など）を使用
- または自前で短縮 URL サービスを実装

---

### 2. 紹介リンクの共有方法

#### 方法 1: QR コード生成と表示 ⭐ 新規追加

**QR コードを生成して表示し、読み取ることで紹介要件を満たす**

**必要なライブラリ：**

```bash
npm install qrcode
npm install @types/qrcode --save-dev
```

**実装例：**

```typescript
// components/ReferralQRCode.tsx
"use client";

import { useState, useEffect } from "react";
import QRCode from "qrcode";

export default function ReferralQRCode({
  referralLink,
}: {
  referralLink: string;
}) {
  const [qrCodeDataUrl, setQrCodeDataUrl] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const generateQRCode = async () => {
      try {
        // QRコードを生成（Data URL形式）
        const dataUrl = await QRCode.toDataURL(referralLink, {
          width: 300,
          margin: 2,
          color: {
            dark: "#000000",
            light: "#FFFFFF",
          },
        });
        setQrCodeDataUrl(dataUrl);
      } catch (error) {
        console.error("QRコード生成エラー:", error);
      } finally {
        setLoading(false);
      }
    };

    if (referralLink) {
      generateQRCode();
    }
  }, [referralLink]);

  if (loading) {
    return <div>QRコードを生成中...</div>;
  }

  if (!qrCodeDataUrl) {
    return <div>QRコードの生成に失敗しました</div>;
  }

  return (
    <div className="flex flex-col items-center space-y-4">
      <h3 className="text-lg font-bold">友達にQRコードを共有</h3>
      <div className="bg-white p-4 rounded-lg shadow-lg">
        <img src={qrCodeDataUrl} alt="紹介QRコード" className="w-64 h-64" />
      </div>
      <p className="text-sm text-gray-600">
        このQRコードを友達に読み取ってもらうと、紹介が成立します
      </p>
      <button
        onClick={() => {
          // QRコード画像をダウンロード
          const link = document.createElement("a");
          link.download = "referral-qrcode.png";
          link.href = qrCodeDataUrl;
          link.click();
        }}
        className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
      >
        QRコードを保存
      </button>
    </div>
  );
}
```

**QR コード読み取り機能（被紹介者が QR コードを読み取る）：**

```typescript
// components/QRCodeScanner.tsx
"use client";

import { useState, useRef, useEffect } from "react";
import { Html5Qrcode } from "html5-qrcode";

export default function QRCodeScanner({
  onScanSuccess,
}: {
  onScanSuccess: (url: string) => void;
}) {
  const [isScanning, setIsScanning] = useState(false);
  const scannerRef = useRef<Html5Qrcode | null>(null);
  const scannerId = "qr-scanner";

  useEffect(() => {
    return () => {
      // クリーンアップ
      if (scannerRef.current) {
        scannerRef.current.stop().catch(() => {});
      }
    };
  }, []);

  const startScanning = async () => {
    try {
      const html5QrCode = new Html5Qrcode(scannerId);
      scannerRef.current = html5QrCode;

      await html5QrCode.start(
        { facingMode: "environment" }, // カメラ設定（背面カメラ）
        {
          fps: 10,
          qrbox: { width: 250, height: 250 },
        },
        (decodedText) => {
          // QRコード読み取り成功
          onScanSuccess(decodedText);
          stopScanning();
        },
        (errorMessage) => {
          // エラーは無視（継続的にスキャンするため）
        }
      );
      setIsScanning(true);
    } catch (error) {
      console.error("QRコードスキャン開始エラー:", error);
      alert("カメラへのアクセスに失敗しました");
    }
  };

  const stopScanning = async () => {
    if (scannerRef.current) {
      try {
        await scannerRef.current.stop();
        scannerRef.current.clear();
      } catch (error) {
        console.error("QRコードスキャン停止エラー:", error);
      }
      scannerRef.current = null;
    }
    setIsScanning(false);
  };

  return (
    <div className="flex flex-col items-center space-y-4">
      <div id={scannerId} className="w-full max-w-md"></div>
      {!isScanning ? (
        <button
          onClick={startScanning}
          className="px-6 py-3 bg-green-500 text-white rounded hover:bg-green-600"
        >
          QRコードをスキャン
        </button>
      ) : (
        <button
          onClick={stopScanning}
          className="px-6 py-3 bg-red-500 text-white rounded hover:bg-red-600"
        >
          スキャン停止
        </button>
      )}
    </div>
  );
}
```

**必要なライブラリ（QR コード読み取り）：**

```bash
npm install html5-qrcode
```

**QR コード読み取り後の処理：**

```typescript
// app/page.tsx など
const handleQRCodeScan = async (scannedUrl: string) => {
  try {
    // URLから紹介リンクIDを抽出
    const url = new URL(scannedUrl);
    const referralLinkId = url.searchParams.get("ref");

    if (!referralLinkId) {
      alert("無効なQRコードです");
      return;
    }

    // 紹介リンクの検証
    const response = await fetch("/api/referral/verify", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        referralLinkId,
      }),
    });

    if (response.ok) {
      const data = await response.json();
      if (data.isValid) {
        sessionStorage.setItem("referralLinkId", referralLinkId);
        alert(
          "紹介リンクが適用されました！初回ガチャ実行時に無料ガチャが付与されます。"
        );
        // 必要に応じてページをリロードまたはリダイレクト
        window.location.href = "/";
      } else {
        alert(`無効な紹介リンクです: ${data.reason}`);
      }
    }
  } catch (error) {
    console.error("QRコード処理エラー:", error);
    alert("QRコードの処理に失敗しました");
  }
};
```

**統合 UI 例（リンク送信と QR コード表示の両方）：**

```typescript
// components/ReferralShare.tsx
"use client";

import { useState } from "react";
import liff from "@line/liff";
import ReferralQRCode from "./ReferralQRCode";

type ShareMethod = "link" | "qr";

export default function ReferralShare({ userId }: { userId: string }) {
  const [referralLink, setReferralLink] = useState<string | null>(null);
  const [shareMethod, setShareMethod] = useState<ShareMethod>("link");
  const [loading, setLoading] = useState(false);

  const generateReferralLink = async () => {
    setLoading(true);
    try {
      const response = await fetch("/api/referral/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userId }),
      });

      const data = await response.json();
      setReferralLink(data.referralLink);
    } catch (error) {
      console.error("エラー:", error);
      alert("紹介リンクの生成に失敗しました");
    } finally {
      setLoading(false);
    }
  };

  const shareLink = async () => {
    if (!referralLink) return;

    if (liff.isInClient()) {
      try {
        await liff.shareTargetPicker([
          {
            type: "text",
            text: `ポーカーガチャアプリを始めませんか？\n${referralLink}\n\n紹介コードで1回無料ガチャがもらえます！`,
          },
        ]);
      } catch (error) {
        console.error("シェアエラー:", error);
      }
    } else {
      await navigator.clipboard.writeText(referralLink);
      alert("紹介リンクをクリップボードにコピーしました！");
    }
  };

  return (
    <div className="space-y-4">
      {!referralLink ? (
        <button
          onClick={generateReferralLink}
          disabled={loading}
          className="w-full rounded-lg bg-blue-500 px-6 py-3 text-white hover:bg-blue-600 disabled:bg-gray-400"
        >
          {loading ? "生成中..." : "紹介リンクを生成"}
        </button>
      ) : (
        <>
          {/* 共有方法の選択 */}
          <div className="flex space-x-2">
            <button
              onClick={() => setShareMethod("link")}
              className={`flex-1 px-4 py-2 rounded ${
                shareMethod === "link"
                  ? "bg-blue-500 text-white"
                  : "bg-gray-200 text-gray-700"
              }`}
            >
              リンクで共有
            </button>
            <button
              onClick={() => setShareMethod("qr")}
              className={`flex-1 px-4 py-2 rounded ${
                shareMethod === "qr"
                  ? "bg-blue-500 text-white"
                  : "bg-gray-200 text-gray-700"
              }`}
            >
              QRコードで共有
            </button>
          </div>

          {/* リンク共有 */}
          {shareMethod === "link" && (
            <div className="space-y-2">
              <div className="p-3 bg-gray-100 rounded break-all text-sm">
                {referralLink}
              </div>
              <button
                onClick={shareLink}
                className="w-full rounded-lg bg-green-500 px-6 py-3 text-white hover:bg-green-600"
              >
                友達に送信
              </button>
              <button
                onClick={async () => {
                  await navigator.clipboard.writeText(referralLink);
                  alert("クリップボードにコピーしました");
                }}
                className="w-full rounded-lg bg-gray-500 px-6 py-3 text-white hover:bg-gray-600"
              >
                リンクをコピー
              </button>
            </div>
          )}

          {/* QRコード表示 */}
          {shareMethod === "qr" && (
            <ReferralQRCode referralLink={referralLink} />
          )}
        </>
      )}
    </div>
  );
}
```

**注意事項：**

1. **QR コード読み取りの権限**

   - カメラへのアクセス権限が必要
   - HTTPS 環境で動作（セキュリティ要件）

2. **QR コードのサイズ**

   - モバイル画面でも読み取りやすいサイズ（300x300px 以上推奨）
   - 誤り訂正レベルを適切に設定

3. **QR コードの有効期限**
   - 紹介リンクと同じ有効期限を適用
   - 期限切れの QR コードは読み取っても無効

---

#### 方法 2: LINE アプリ内でのシェア（リンク送信）

**LIFF API: `liff.shareTargetPicker()`**

```typescript
import liff from "@line/liff";

const shareReferralLink = async (referralLink: string) => {
  if (liff.isInClient()) {
    // LINEアプリ内の場合
    try {
      await liff.shareTargetPicker([
        {
          type: "text",
          text: `ポーカーガチャアプリを始めませんか？\n${referralLink}\n\n紹介コードで1回無料ガチャがもらえます！`,
        },
      ]);
    } catch (error) {
      console.error("シェアエラー:", error);
      // シェアがキャンセルされた場合など
    }
  } else {
    // 外部ブラウザの場合
    // クリップボードにコピーするか、別の方法で共有
    await navigator.clipboard.writeText(referralLink);
    alert("紹介リンクをクリップボードにコピーしました");
  }
};
```

**制約：**

- LINE アプリ内でのみ動作
- ユーザーがシェア先を選択する必要がある
- シェアがキャンセルされる可能性がある

#### 方法 3: 外部ブラウザで開く

**LIFF API: `liff.openWindow()`**

```typescript
const shareViaExternalBrowser = (referralLink: string) => {
  if (liff.isInClient()) {
    // 外部ブラウザで開く
    liff.openWindow({
      url: referralLink,
      external: true,
    });
  } else {
    // 既に外部ブラウザの場合
    window.open(referralLink, "_blank");
  }
};
```

#### 方法 4: クリップボードにコピー

```typescript
const copyToClipboard = async (referralLink: string) => {
  try {
    await navigator.clipboard.writeText(referralLink);
    alert(
      "紹介リンクをクリップボードにコピーしました！\n友達に送ってください。"
    );
  } catch (error) {
    console.error("コピーエラー:", error);
    // フォールバック: テキストエリアを使用
    const textArea = document.createElement("textarea");
    textArea.value = referralLink;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand("copy");
    document.body.removeChild(textArea);
    alert("紹介リンクをコピーしました！");
  }
};
```

---

### 3. 紹介リンクの検証（被紹介者がアクセスした時）

#### URL パラメータの取得

```typescript
// app/page.tsx または適切なコンポーネント
"use client";

import { useEffect, useState } from "react";
import { useSearchParams } from "next/navigation";

export default function Home() {
  const searchParams = useSearchParams();
  const [referralLinkId, setReferralLinkId] = useState<string | null>(null);

  useEffect(() => {
    // URLパラメータから紹介リンクIDを取得
    const ref = searchParams.get("ref");
    if (ref) {
      setReferralLinkId(ref);
      // 紹介リンクの検証と保存
      handleReferralLink(ref);
    }
  }, [searchParams]);

  const handleReferralLink = async (linkId: string) => {
    try {
      // 1. 紹介リンクの検証APIを呼び出し
      const response = await fetch("/api/referral/verify", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          referralLinkId: linkId,
          // IPアドレスやデバイス情報も送信（サーバー側で取得も可能）
        }),
      });

      if (response.ok) {
        const data = await response.json();
        if (data.isValid) {
          // 紹介リンクが有効な場合、セッションストレージに保存
          sessionStorage.setItem("referralLinkId", linkId);
          // ユーザーに通知
          alert(
            "紹介リンクが適用されました！初回ガチャ実行時に無料ガチャが付与されます。"
          );
        } else {
          console.error("無効な紹介リンク:", data.reason);
        }
      }
    } catch (error) {
      console.error("紹介リンク検証エラー:", error);
    }
  };

  // ... その他のコード
}
```

#### サーバー側での検証 API

```typescript
// app/api/referral/verify/route.ts
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { referralLinkId } = body;

    // IPアドレスを取得
    const ipAddress =
      request.headers.get("x-forwarded-for") ||
      request.headers.get("x-real-ip") ||
      "unknown";

    // 紹介リンクの検証
    const referral = await prisma.referralHistory.findUnique({
      where: { referralLinkId },
    });

    if (!referral) {
      return NextResponse.json(
        {
          isValid: false,
          reason: "紹介リンクが見つかりません",
        },
        { status: 404 }
      );
    }

    // 有効期限チェック
    if (new Date() > referral.expiresAt) {
      await prisma.referralHistory.update({
        where: { id: referral.id },
        data: { status: "expired" },
      });
      return NextResponse.json({
        isValid: false,
        reason: "紹介リンクの有効期限が切れています",
      });
    }

    // ステータスチェック
    if (referral.status !== "pending") {
      return NextResponse.json({
        isValid: false,
        reason: "この紹介リンクは既に使用済みです",
      });
    }

    // IPアドレスとデバイス情報を更新
    await prisma.referralHistory.update({
      where: { id: referral.id },
      data: {
        ipAddress,
        deviceInfo: request.headers.get("user-agent") || "unknown",
        referredAt: new Date(),
      },
    });

    return NextResponse.json({
      isValid: true,
      referralId: referral.id,
    });
  } catch (error) {
    console.error("紹介リンク検証エラー:", error);
    return NextResponse.json({ error: "検証に失敗しました" }, { status: 500 });
  }
}
```

---

### 4. 紹介成立の判定（初回ガチャ実行時）

```typescript
// app/api/gacha/route.ts または適切なAPI
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { userId, gachaType } = body;

    // セッションストレージから紹介リンクIDを取得（クライアント側から送信）
    // または、データベースから未成立の紹介履歴を検索
    const referralHistory = await prisma.referralHistory.findFirst({
      where: {
        refereeId: userId, // 被紹介者ID
        status: "pending",
      },
    });

    // ガチャ抽選処理
    // ...

    // 初回ガチャ実行の場合、紹介を成立させる
    const isFirstGacha = await checkIsFirstGacha(userId);

    if (isFirstGacha && referralHistory) {
      // 1. 紹介履歴を更新
      await prisma.referralHistory.update({
        where: { id: referralHistory.id },
        data: {
          refereeId: userId,
          status: "completed",
          completedAt: new Date(),
        },
      });

      // 2. 紹介者と被紹介者の両方に無料ガチャを付与
      await prisma.freeGachaHistory.createMany({
        data: [
          {
            userId: referralHistory.referrerId, // 紹介者
            referralHistoryId: referralHistory.id,
            grantType: "referrer",
            isUsed: false,
            expiresAt: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90日後
          },
          {
            userId: userId, // 被紹介者
            referralHistoryId: referralHistory.id,
            grantType: "referee",
            isUsed: false,
            expiresAt: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90日後
          },
        ],
      });
    }

    // ガチャ抽選結果を返す
    // ...
  } catch (error) {
    // エラーハンドリング
  }
}
```

---

### 5. 不正防止の実装

#### 重複紹介の防止

```typescript
// 紹介リンク検証時にチェック
const checkDuplicateReferral = async (
  referrerId: string,
  refereeId: string
) => {
  const existing = await prisma.referralHistory.findFirst({
    where: {
      referrerId,
      refereeId,
      status: { in: ["pending", "completed"] },
    },
  });

  if (existing) {
    throw new Error("既に紹介済みです");
  }
};
```

#### 自己紹介の防止

```typescript
// 紹介リンク検証時にチェック
if (referral.referrerId === userId) {
  await prisma.referralHistory.update({
    where: { id: referral.id },
    data: {
      status: "invalid",
      isFraudDetected: true,
      fraudReason: "自己紹介",
    },
  });
  return NextResponse.json({
    isValid: false,
    reason: "自己紹介はできません",
  });
}
```

#### 異常パターンの検知

```typescript
// 同一IPからの大量紹介を検知
const checkSuspiciousActivity = async (ipAddress: string) => {
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);

  const recentReferrals = await prisma.referralHistory.count({
    where: {
      ipAddress,
      createdAt: { gte: oneHourAgo },
    },
  });

  if (recentReferrals >= 5) {
    // 1時間以内に5回以上の紹介 = 異常
    return true;
  }

  return false;
};
```

---

## UI 実装例

### 紹介リンク生成・共有ボタン

```typescript
// components/ReferralButton.tsx
"use client";

import { useState } from "react";
import liff from "@line/liff";

export default function ReferralButton({ userId }: { userId: string }) {
  const [referralLink, setReferralLink] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const generateAndShare = async () => {
    setLoading(true);
    try {
      // 1. 紹介リンクを生成
      const response = await fetch("/api/referral/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userId }),
      });

      const data = await response.json();
      setReferralLink(data.referralLink);

      // 2. シェア
      if (liff.isInClient()) {
        await liff.shareTargetPicker([
          {
            type: "text",
            text: `ポーカーガチャアプリを始めませんか？\n${data.referralLink}\n\n紹介コードで1回無料ガチャがもらえます！`,
          },
        ]);
      } else {
        // 外部ブラウザの場合、クリップボードにコピー
        await navigator.clipboard.writeText(data.referralLink);
        alert("紹介リンクをクリップボードにコピーしました！");
      }
    } catch (error) {
      console.error("エラー:", error);
      alert("紹介リンクの生成に失敗しました");
    } finally {
      setLoading(false);
    }
  };

  return (
    <button
      onClick={generateAndShare}
      disabled={loading}
      className="rounded-lg bg-blue-500 px-6 py-3 text-white hover:bg-blue-600 disabled:bg-gray-400"
    >
      {loading ? "生成中..." : "友達を招待する"}
    </button>
  );
}
```

---

## 注意事項

### LINE LIFF の制約

1. **`liff.shareTargetPicker()`の制約**

   - LINE アプリ内でのみ動作
   - ユーザーがシェア先を選択する必要がある
   - シェアがキャンセルされる可能性がある

2. **URL パラメータの制約**

   - LIFF URL に直接パラメータを含める必要がある
   - 長い URL は見た目が悪い（短縮 URL の検討）

3. **セッション管理**
   - 紹介リンク ID はセッションストレージまたはクッキーに保存
   - ブラウザを閉じると失われる可能性がある

### セキュリティ考慮事項

1. **紹介リンク ID の推測を防ぐ**

   - UUID や暗号化された ID を使用
   - 推測しにくい形式にする

2. **IP アドレスの信頼性**

   - プロキシや VPN 経由の場合、正確な IP が取得できない可能性
   - 複数の検証方法を組み合わせる

3. **デバイス情報の取得**
   - User-Agent は簡単に偽装可能
   - 補助的な検証手段として使用

---

## まとめ

LINE ミニアプリでの友達紹介システムは以下の方法で実現可能：

1. **紹介リンク生成**: URL パラメータに紹介者 ID を含める
2. **共有**: `liff.shareTargetPicker()`またはクリップボードコピー
3. **検証**: URL パラメータから紹介リンク ID を取得し、サーバー側で検証
4. **成立判定**: 被紹介者の初回ガチャ実行時に判定
5. **不正防止**: 重複紹介、自己紹介、異常パターンの検知
